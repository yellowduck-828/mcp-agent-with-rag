<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MyAgent Chat</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    />
    <style>
      body {
        margin: 0;
        background: linear-gradient(#fafafa, #eaeaea);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
        color: #0f172a;
      }
      /* é¡¶æ  */
      .header {
        height: 52px;
        background: #fff;
        border-bottom: 1px solid #e5e5e5;
        display: flex;
        align-items: center;
        padding: 0 16px;
        font-size: 18px;
        font-weight: 600;
        gap: 12px;
      }
      .session-badge {
        margin-left: auto;
        font-size: 12px;
        color: #64748b;
      }
      /* æ•´ä½“å¸ƒå±€ */
      .container {
        display: flex;
        height: calc(100vh - 52px);
      }
      /* å·¦ä¾§ä¾§æ  */
      .sidebar {
        width: 220px;
        background: #fff;
        border-right: 1px solid #e5e5e5;
      }
      .sidebar .title {
        padding: 14px;
        color: #666;
        font-size: 14px;
      }
      .chat-list div {
        padding: 12px 14px;
        cursor: pointer;
      }
      .chat-list div:hover {
        background: #f7f7f7;
      }
      /* å³ä¾§ä¸»èŠå¤©åŒº */
      .chat-area {
        flex: 1;
        display: flex;
        flex-direction: column;
      }
      /* èŠå¤©å†…å®¹æ»šåŠ¨åŒºåŸŸ */
      .messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px 30px;
        display: flex;
        flex-direction: column;
      }
      /* Markdown å†…å®¹ä¸­çš„é“¾æ¥æ¸²æŸ“ä¸ºæŒ‰é’®æ ·å¼ */
      .md-content a {
        display: inline-block;
        padding: 6px 10px;
        margin: 4px 0;
        border-radius: 6px;
        background: #e0f2fe;
        color: #0f172a;
        text-decoration: none;
        border: 1px solid #bae6fd;
        font-weight: 600;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
        transition: background 0.15s ease, transform 0.1s ease;
      }
      .md-content a:hover {
        background: #bae6fd;
        transform: translateY(-1px);
      }
      .md-content a:active {
        transform: translateY(0);
      }
      /* AI æ¶ˆæ¯ */
      .msg-ai {
        max-width: 70%;
        background: #fff;
        border: 1px solid #e5e5e5;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        padding: 12px 14px;
        border-radius: 14px;
        margin-bottom: 12px;
      }
      /* ç”¨æˆ·æ¶ˆæ¯ */
      .msg-user {
        max-width: 70%;
        background: #3b82f6;
        color: white;
        padding: 12px 14px;
        border-radius: 14px;
        margin-bottom: 12px;
        margin-left: auto;
      }
      /* åº•éƒ¨è¾“å…¥åŒºåŸŸ */
      .input-area {
        background: #fff;
        border-top: 1px solid #e5e5e5;
        padding: 14px;
        display: flex;
        gap: 12px;
      }
      textarea {
        flex: 1;
        resize: none;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #ddd;
        outline: none;
        font-size: 14px;
        background: #fff;
        color: #0f172a;
      }
      textarea:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.18);
      }
      button {
        background: #3b82f6;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 14px;
      }
      button:hover {
        background: #2563eb;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .loading {
        display: flex;
        align-items: center;
        gap: 8px;
        color: #64748b;
        font-size: 14px;
        margin: 4px 0 8px;
      }
      .dot {
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: #2563eb;
        animation: pulse 1s infinite;
      }
      @keyframes pulse {
        0% { opacity: 0.4; }
        50% { opacity: 1; }
        100% { opacity: 0.4; }
      }
      /* markdown æ ·å¼ç®€åŒ– */
      .md-content p { margin: 6px 0; }
      .md-content code {
        padding: 2px 6px;
        background: #f3f4f6;
        border-radius: 6px;
        font-size: 13px;
      }
      .md-content pre {
        background: #0f172a;
        color: #e2e8f0;
        padding: 10px;
        border-radius: 10px;
        overflow: auto;
        font-size: 13px;
      }
      .md-content pre code {
        background: transparent;
        padding: 0;
      }
      .md-content ul {
        margin: 6px 0;
        padding-left: 20px;
      }
      .think-toggle {
        margin-top: 4px;
        font-size: 12px;
        color: #2563eb;
        cursor: pointer;
        user-select: none;
      }
      .think-box {
        margin-top: 6px;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #e5e7eb;
        background: #f8fafc;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React UMD + Babelï¼ˆç”¨äºåœ¨æµè§ˆå™¨å†…ç¼–è¯‘ JSXï¼‰ -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    ></script>
    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      const BASE_URL = "http://127.0.0.1:8000";

      // å…¨å±€é…ç½® markedï¼Œé¿å… mangle/headers å½±å“æ¸²æŸ“
      marked.setOptions({
        gfm: true,
        breaks: true,
        mangle: false,
        headerIds: false,
      });

      const ToolChips = ({ tools }) => {
        if (!tools || tools.length === 0) return null;
        return (
          <div style={{ marginTop: "6px", display: "flex", flexWrap: "wrap", gap: "6px", fontSize: "12px" }}>
            {tools.map((t, i) => (
              <span
                key={i}
                style={{
                  padding: "4px 8px",
                  borderRadius: "999px",
                  background: "#fef3c7",
                  color: "#b45309",
                  border: "1px solid #fde68a",
                }}
              >
                {`ğŸ”§${i + 1} ${t}`}
              </span>
            ))}
          </div>
        );
      };

      // è§£æä¸¥æ ¼æ ‡ç­¾ï¼Œé¿å…å±•ç¤ºæ¨¡å‹è‡†é€ å†…å®¹
      const parseTags = (text = "") => {
        const first = (tag) => {
          const m = text.match(new RegExp(`<${tag}>([\\s\\S]*?)<\\/${tag}>`, "i"));
          return ((m && m[1]) || "").trim();
        };
        const thought = first("thought");
        const action = first("action");
        const finalMatchNew = text.match(/<final_answer>([\s\S]*?)<\/final_answer>/i);
        const finalMatchOld = text.match(/<final>([\s\S]*?)<\/final>/i);
        const finalAnswer = ((finalMatchNew ? finalMatchNew[1] : finalMatchOld ? finalMatchOld[1] : "") || "").trim();
        return { thought, action, finalAnswer };
      };

      const MessageBubble = ({ msg }) => {
        const isUser = msg.role === "user";

        const useMarkdown = (content) => {
          const ref = useRef(null);
          const html = React.useMemo(() => {
            if (!marked || !DOMPurify) return content || "";
            marked.setOptions({ gfm: true, breaks: true });
            const raw = marked.parse(content || "");
            return DOMPurify.sanitize(raw);
          }, [content]);

          useEffect(() => {
            if (ref.current && window.renderMathInElement) {
              window.renderMathInElement(ref.current, {
                delimiters: [
                  { left: "$$", right: "$$", display: true },
                  { left: "$", right: "$", display: false },
                  { left: "\\(", right: "\\)", display: false },
                  { left: "\\[", right: "\\]", display: true },
                ],
                throwOnError: false,
              });
            }
          }, [html]);

          return { html, ref };
        };

        const steps = msg.steps || [];
        const hasSteps = steps.length > 0;
        const contentText = (msg.content || "").trim();
        const displayFinal =
          (msg.finalAnswer && msg.finalAnswer.trim()) ||
          // å¦‚æœæ¨¡å‹æœªè¾“å‡º <final_answer>ï¼Œä½†æœ‰æ­£æ–‡ä¸”ä¸åªæ˜¯æ ‡ç­¾ï¼Œåˆ™ç›´æ¥å±•ç¤ºæ­£æ–‡
          (contentText && !/<(thought|action|observation)>/i.test(contentText) ? contentText : "") ||
          (hasSteps ? "ï¼ˆæ¨¡å‹æ€è€ƒä¸­ / ç­‰å¾…å·¥å…·ç»“æœï¼‰" : contentText || "");

        const finalRender = useMarkdown(displayFinal);
        const stepsMarkdown = steps
          .map((s) => `**[${s.tag}]**\n${s.content || "ï¼ˆç©ºï¼‰"}`)
          .join("\n\n");
        const stepsRender = useMarkdown(stepsMarkdown);

        const finalInner = (
          <div
            className="md-content"
            ref={finalRender.ref}
            dangerouslySetInnerHTML={{ __html: finalRender.html || displayFinal }}
          />
        );

        const thinkInner =
          hasSteps && (
            <details className="think-box" style={{ marginTop: "6px" }}>
              <summary style={{ cursor: "pointer", color: "#2563eb", fontSize: "12px", marginBottom: "6px" }}>
                {"æ€è€ƒ / å·¥å…·è°ƒç”¨ï¼ˆç‚¹å‡»å±•å¼€/æ”¶èµ·ï¼‰"}
              </summary>
              <div className="md-content" ref={stepsRender.ref} dangerouslySetInnerHTML={{ __html: stepsRender.html || stepsMarkdown }} />
              <div style={{ marginTop: "8px" }}>
                <ToolChips tools={msg.tools} />
              </div>
            </details>
          );

        if (isUser) {
          return <div className="msg-user">{finalInner}</div>;
        }

        return (
          <div className="msg-ai">
            {finalInner}
            {thinkInner}
          </div>
        );
      };

      function App() {
        const genId = () =>
          typeof crypto !== "undefined" && crypto.randomUUID
            ? crypto.randomUUID()
            : `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;

        const createChat = (title = "æ–°ä¼šè¯") => ({
          id: genId(),
          title,
          sessionId: null,
          messages: [{ role: "assistant", content: "ä½ å¥½ï¼Œæˆ‘æ˜¯ä½ çš„æ™ºèƒ½åŠ©æ‰‹ã€‚", tools: [] }],
        });

        const [chats, setChats] = useState([createChat()]);
        const [activeId, setActiveId] = useState(null);
        const [loadingChatId, setLoadingChatId] = useState(null);
        const [menuOpenId, setMenuOpenId] = useState(null);
        const [input, setInput] = useState("");
        const listRef = useRef(null);
        const streamAbortRef = useRef(null);
        const finalAbortRef = useRef(null);
        const abortedRef = useRef(false);
        const [workspaceOpen, setWorkspaceOpen] = useState(false);
        const [workspacePath, setWorkspacePath] = useState(".");
        const [workspaceAbs, setWorkspaceAbs] = useState("");
        const [workspaceItems, setWorkspaceItems] = useState([]);
        const [workspaceLoading, setWorkspaceLoading] = useState(false);
        const [workspaceError, setWorkspaceError] = useState("");

        useEffect(() => {
          if (!activeId && chats.length > 0) {
            setActiveId(chats[0].id);
          }
        }, [activeId, chats]);

        useEffect(() => {
          if (listRef.current) {
            listRef.current.scrollTop = listRef.current.scrollHeight;
          }
        }, [activeId, chats, loadingChatId]);

        const currentChat = chats.find((c) => c.id === activeId);
        const currentMessages = currentChat ? currentChat.messages : [];

        // ç”ŸæˆåªåŒ…å« user/assistant çš„å±•ç¤ºæ¶ˆæ¯ï¼ŒæŠŠå·¥å…· observation å½’å¹¶åˆ°å‰ä¸€æ¡ assistant
        const displayMessages = React.useMemo(() => {
          const msgs = currentMessages || [];
          const result = [];
          let pendingObservations = [];

          for (const m of msgs) {
            if (m.role === "tool") {
              pendingObservations.push(m.content || "");
              continue;
            }

            if (m.role === "user") {
              // ç”¨æˆ·æ¶ˆæ¯æ¸…ç©ºæŒ‚èµ·çš„ observationï¼Œé¿å…è¯¯æŒ‚
              pendingObservations = [];
              result.push({ ...m, steps: [], finalAnswer: "" });
              continue;
            }

            if (m.role === "assistant") {
              const parsed = parseTags(m.content || "");
              const steps = [];
              if (parsed.thought) steps.push({ tag: "thought", content: parsed.thought });
              if (parsed.action) steps.push({ tag: "action", content: parsed.action });
              steps.push(...pendingObservations.map((c) => ({ tag: "observation", content: c })));

              // è‹¥å­˜åœ¨å·¥å…·è°ƒç”¨è®°å½•ä½†æœªåœ¨æ­¥éª¤ä¸­ä½“ç°ï¼Œè¿½åŠ å ä½ actionï¼Œé¿å…ä¸å®é™…è°ƒç”¨ä¸ç¬¦
              const toolNames = Array.isArray(m.tools) ? m.tools : [];
              const existingActions = steps.filter((s) => s.tag === "action").map((s) => s.content);
              const extraTools = toolNames.filter((t) => !existingActions.some((a) => a.includes(t)));
              extraTools.forEach((t) => steps.push({ tag: "action", content: `è°ƒç”¨å·¥å…·ï¼š${t}ï¼ˆè®°å½•è‡ªåç«¯ï¼‰` }));

              pendingObservations = [];

              result.push({
                ...m,
                steps,
                finalAnswer: parsed.finalAnswer,
              });
            }
          }

          return result;
        }, [currentMessages]);

        async function fetchWorkspace(path = ".") {
          setWorkspaceLoading(true);
          setWorkspaceError("");
          try {
            const resp = await fetch(`${BASE_URL}/workspace/list?path=${encodeURIComponent(path)}`);
            if (!resp.ok) throw new Error("è·å–å¤±è´¥");
            const data = await resp.json();
            setWorkspacePath(data.path || path);
            setWorkspaceAbs(data.abs_path || "");
            setWorkspaceItems(Array.isArray(data.items) ? data.items : []);
          } catch (err) {
            setWorkspaceError("åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯æˆ–è·¯å¾„æƒé™ã€‚");
          } finally {
            setWorkspaceLoading(false);
          }
        }

        function openWorkspace() {
          setWorkspaceOpen(true);
          fetchWorkspace(".");
        }

        function closeWorkspace() {
          setWorkspaceOpen(false);
          setWorkspaceItems([]);
          setWorkspaceError("");
        }

        function goUpWorkspace() {
          if (workspacePath === ".") return;
          const parts = workspacePath.split("/").filter(Boolean);
          parts.pop();
          const newPath = parts.length ? parts.join("/") : ".";
          fetchWorkspace(newPath);
        }

        function enterWorkspace(name, isDir) {
          if (!isDir) return;
          const newPath = workspacePath === "." ? name : `${workspacePath}/${name}`;
          fetchWorkspace(newPath);
        }

        const summarizeTitle = (text = "") => {
          const cleaned = text.trim().replace(/\s+/g, " ");
          if (!cleaned) return "æ–°ä¼šè¯";
          const maxLen = 14;
          return cleaned.length > maxLen ? `${cleaned.slice(0, maxLen)}â€¦` : cleaned;
        };

        async function handleUpload(e) {
          const file = e.target.files?.[0];
          if (!file) return;
          const form = new FormData();
          form.append("file", file);
          try {
            setWorkspaceLoading(true);
            const resp = await fetch(`${BASE_URL}/workspace/upload?path=${encodeURIComponent(workspacePath)}`, {
              method: "POST",
              body: form,
            });
            if (!resp.ok) throw new Error("ä¸Šä¼ å¤±è´¥");
            await fetchWorkspace(workspacePath);
          } catch (err) {
            setWorkspaceError("ä¸Šä¼ å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚");
          } finally {
            setWorkspaceLoading(false);
            e.target.value = "";
          }
        }

        function addChat() {
          const newChat = createChat(`ä¼šè¯ ${chats.length + 1}`);
          setChats((prev) => [...prev, newChat]);
          setActiveId(newChat.id);
          setInput("");
          setMenuOpenId(null);
        }

        async function deleteChat(e, chatId) {
          e.stopPropagation();
          const target = chats.find((c) => c.id === chatId);
          if (!target) return;
          if (!window.confirm("ç¡®å®šåˆ é™¤è¯¥å¯¹è¯ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤")) return;

          // åç«¯åˆ é™¤å¯¹åº” session çš„æŒä¹…åŒ–
          if (target.sessionId) {
            fetch(`${BASE_URL}/chat/session/${target.sessionId}`, { method: "DELETE" }).catch(() => {});
          }

          setChats((prev) => {
            const filtered = prev.filter((c) => c.id !== chatId);
            if (filtered.length === 0) {
              const newChat = createChat();
              setActiveId(newChat.id);
              return [newChat];
            }
            // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä¼šè¯ï¼Œåˆ‡æ¢åˆ°åˆ—è¡¨é¦–ä¸ª
            if (activeId === chatId) {
              setActiveId(filtered[0].id);
            }
            return filtered;
          });
          setMenuOpenId(null);
          setInput("");
        }

        async function fetchFinalWithTools(message, sid, chatId, signal) {
          const resp = await fetch(`${BASE_URL}/chat`, {
            method: "POST",
            headers: { "Content-Type": "application/json", Accept: "application/json" },
            body: JSON.stringify({ message, session_id: sid }),
            signal,
          });
          if (!resp.ok) throw new Error("å·¥å…·è°ƒç”¨å¤±è´¥");
          const data = await resp.json();
          const reply = data.reply || "ï¼ˆæ— å›å¤ï¼‰";
          const usedTools = Array.isArray(data.tools) ? data.tools : [];
          const toolResults = Array.isArray(data.tool_results) ? data.tool_results : [];
          const sessionIdFromResp = data.session_id || sid;

          setChats((prev) =>
            prev.map((c) =>
              c.id === chatId
                ? (() => {
                    const msgs = [...c.messages];
                    // ç§»é™¤æµå¼å ä½çš„æœ€åä¸€æ¡ assistantï¼Œé¿å…è§‚æµ‹æŒ‚ä¸åˆ°ä¸‹ä¸€æ¡
                    if (msgs.length > 0 && msgs[msgs.length - 1].role === "assistant") {
                      msgs.pop();
                    }
                    // æ’å…¥å·¥å…· observation
                    const toolMsgs = toolResults.map((obs) => ({ role: "tool", content: obs }));
                    msgs.push(...toolMsgs);
                    // è¿½åŠ æœ€ç»ˆ assistant
                    msgs.push({ role: "assistant", content: reply, tools: usedTools });
                    return { ...c, sessionId: sessionIdFromResp, messages: msgs };
                  })()
                : c
            )
          );
        }

        async function sendMessage() {
          if (!input.trim() || loadingChatId) return;
          if (!currentChat) return;
          const userMsg = { role: "user", content: input };
          const newTitle = summarizeTitle(userMsg.content);
          setChats((prev) =>
            prev.map((c) =>
              c.id === activeId
                ? {
                    ...c,
                    // ä»…åœ¨åˆæ¬¡å‘½åæ—¶è®¾ç½®æ ‡é¢˜ï¼Œä¹‹åä¸å†è‡ªåŠ¨æ”¹å
                    title:
                      !c.title ||
                      c.title === "æ–°ä¼šè¯" ||
                      /^ä¼šè¯\s*\d+$/u.test(c.title.trim())
                        ? newTitle
                        : c.title,
                    messages: [...c.messages, userMsg, { role: "assistant", content: "", tools: [] }],
                  }
                : c
            )
          );
          setInput("");
          setLoadingChatId(activeId);
          abortedRef.current = false;

          const currentSession = currentChat.sessionId;
          const streamController = new AbortController();
          streamAbortRef.current = streamController;

          try {
            const resp = await fetch(`${BASE_URL}/chat/stream`, {
              method: "POST",
              headers: { "Content-Type": "application/json", Accept: "text/event-stream" },
              body: JSON.stringify({ message: userMsg.content, session_id: currentSession }),
              signal: streamController.signal,
            });

            const sidHeader = resp.headers.get("x-session-id");
            const sidFromStream = sidHeader || currentSession;
            if (sidHeader) {
              setChats((prev) => prev.map((c) => (c.id === activeId ? { ...c, sessionId: sidHeader } : c)));
            }

            if (!resp.body) throw new Error("æ— æµæ•°æ®");
            const reader = resp.body.getReader();
            const decoder = new TextDecoder();
            let buffer = "";
            let full = "";
            const usedTools = [];

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              const parts = buffer.split("\n\n");
              buffer = parts.pop() || "";
              for (const part of parts) {
                const line = part.trim();
                if (line.startsWith("data:")) {
                  const chunk = line.replace(/^data:\s*/, "");
                  full += chunk;
                  // å°†æµå¼å†…å®¹æš‚å­˜ä¸º <think>ï¼Œé¿å…æœªå®Œæˆæ–‡æœ¬å‡ºç°åœ¨ä¸»æ°”æ³¡
                  const thinkWrapped = `<think>${full}</think>`;
                  setChats((prev) =>
                    prev.map((c) =>
                      c.id === activeId
                        ? {
                            ...c,
                            messages: [
                              ...c.messages.slice(0, -1),
                              { role: "assistant", content: thinkWrapped, tools: usedTools },
                            ],
                          }
                        : c
                    )
                  );
                }
              }
            }

            // è‹¥æœªè¢«ç”¨æˆ·ä¸­æ–­ï¼Œå†ç”¨å¸¦å·¥å…·çš„æ¥å£è·å–å®Œæ•´ <think>/<final> ä¸å·¥å…·åˆ—è¡¨
            if (!abortedRef.current) {
              const finalController = new AbortController();
              finalAbortRef.current = finalController;
              await fetchFinalWithTools(userMsg.content, sidFromStream, activeId, finalController.signal);
            }
          } catch (err) {
            if (!abortedRef.current) {
              setChats((prev) =>
                prev.map((c) =>
                  c.id === activeId
                    ? {
                        ...c,
                        messages: [
                          ...c.messages.slice(0, -1),
                          {
                            role: "assistant",
                            content: "è¯·æ±‚å¤±è´¥ï¼Œè¯·ç¡®è®¤åç«¯å·²å¯åŠ¨å¹¶å…è®¸è·¨åŸŸã€‚",
                            tools: [],
                          },
                        ],
                      }
                    : c
                )
              );
            }
          } finally {
            streamAbortRef.current = null;
            finalAbortRef.current = null;
            setLoadingChatId(null);
          }
        }

        function stopStreaming() {
          if (loadingChatId !== activeId) return;
          abortedRef.current = true;
          if (streamAbortRef.current) {
            streamAbortRef.current.abort();
          }
          if (finalAbortRef.current) {
            finalAbortRef.current.abort();
          }
          const sid = currentChat?.sessionId;
          if (sid) {
            // é€šçŸ¥åç«¯ä¸­æ–­å½“å‰ä¼šè¯ï¼Œé¿å…åå°ç»§ç»­è·‘
            fetch(`${BASE_URL}/chat/session/${sid}/cancel`, { method: "POST" }).catch(() => {});
          }
          setLoadingChatId(null);
          setChats((prev) =>
            prev.map((c) => {
              if (c.id !== activeId) return c;
              const msgs = [...c.messages];
              if (msgs.length > 0) {
                const last = msgs[msgs.length - 1];
                if (last.role === "assistant") {
                  const note = last.content ? `${last.content}\nï¼ˆå·²ä¸­æ–­ï¼‰` : "ï¼ˆå·²ä¸­æ–­ï¼‰";
                  msgs[msgs.length - 1] = { ...last, content: note };
                }
              }
              return { ...c, messages: msgs };
            })
          );
        }

        function onKey(e) {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        }

        return (
          <>
          <div className="app">
            <div className="header">
              <div>MyAgent Chat Â· ä½ çš„æ™ºèƒ½åŠ©æ‰‹</div>
              <div style={{ display: "flex", gap: "10px", alignItems: "center" }}>
                <button
                  onClick={openWorkspace}
                  style={{
                    padding: "6px 12px",
                    borderRadius: "6px",
                    border: "1px solid #cbd5e1",
                    background: "#ffffff",
                    cursor: "pointer",
                    color: "#0f172a",
                    fontWeight: 600,
                    minWidth: "88px",
                  }}
                >
                  æ–‡ä»¶ç®¡ç†
                </button>
                {currentChat?.sessionId ? (
                  <span className="session-badge">{`Session: ${currentChat.sessionId.slice(0, 8)}...`}</span>
                ) : null}
              </div>
            </div>

            <div className="container">
              {/* ä¾§æ  */}
              <div className="sidebar">
                  <div className="title" style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                    <span>ä¼šè¯åˆ—è¡¨</span>
                    <button style={{ padding: "4px 8px" }} onClick={addChat}>
                      æ–°å»º
                    </button>
                  </div>
                  <div className="chat-list">
                    {chats.map((c) => (
                      <div
                        key={c.id}
                        style={{
                          padding: "8px",
                          borderRadius: "8px",
                          background: c.id === activeId ? "#e0f2fe" : "#f8fafc",
                          cursor: "pointer",
                          marginBottom: "6px",
                          border: c.id === activeId ? "1px solid #38bdf8" : "1px solid #e2e8f0",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "space-between",
                        }}
                        onClick={() => setActiveId(c.id)}
                      >
                        <span style={{ flex: 1, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>
                          {c.title}
                        </span>
                        <div style={{ position: "relative" }}>
                          <button
                            style={{
                              marginLeft: "8px",
                              padding: "0 6px",
                              borderRadius: "6px",
                              border: "1px solid #e2e8f0",
                              background: "#fff",
                              cursor: "pointer",
                            }}
                            onClick={(e) => {
                              e.stopPropagation();
                              setMenuOpenId((prev) => (prev === c.id ? null : c.id));
                            }}
                          >
                            â‹®
                          </button>
                          {menuOpenId === c.id && (
                            <div
                              style={{
                                position: "absolute",
                                right: 0,
                                top: "110%",
                                background: "#fff",
                                border: "1px solid #e2e8f0",
                                borderRadius: "8px",
                                boxShadow: "0 4px 10px rgba(0,0,0,0.08)",
                                zIndex: 10,
                                minWidth: "100px",
                              }}
                            >
                              <div
                                style={{ padding: "8px", cursor: "pointer", color: "#ef4444" }}
                                onClick={(e) => deleteChat(e, c.id)}
                              >
                                åˆ é™¤å¯¹è¯
                              </div>
                            </div>
                          )}
                        </div>
                      </div>
                    ))}
                </div>
              </div>

              {/* ä¸»èŠå¤©çª—å£ */}
              <div className="chat-area">
                <div className="messages" ref={listRef}>
                    {displayMessages.map((m, idx) => (
                      <MessageBubble key={idx} msg={m} />
                    ))}
                    {loadingChatId === activeId && (
                    <div className="loading">
                      <span className="dot"></span>
                      <span>AI æ­£åœ¨æ€è€ƒ...</span>
                    </div>
                  )}
                </div>

                <div className="input-area">
                  <textarea
                    placeholder="è¾“å…¥æ¶ˆæ¯ï¼Œå›è½¦å‘é€ï¼ˆShift+Enteræ¢è¡Œï¼‰"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={onKey}
                    rows={2}
                  ></textarea>
                  <div style={{ display: "flex", gap: "8px" }}>
                    <button onClick={stopStreaming} disabled={loadingChatId !== activeId}>
                      ä¸­æ–­
                    </button>
                    <button onClick={sendMessage} disabled={loadingChatId === activeId}>
                      å‘é€
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          {workspaceOpen && (
            <div
              style={{
                position: "fixed",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: "rgba(0,0,0,0.35)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 999,
              }}
            >
              <div
                style={{
                  width: "640px",
                  maxHeight: "80vh",
                  background: "#fff",
                  borderRadius: "12px",
                  padding: "16px",
                  boxShadow: "0 10px 30px rgba(0,0,0,0.12)",
                  display: "flex",
                  flexDirection: "column",
                  gap: "12px",
                }}
              >
                <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                  <div style={{ fontWeight: 600 }}>Workspace æµè§ˆ</div>
                  <button
                    onClick={closeWorkspace}
                    style={{
                      width: "28px",
                      height: "28px",
                      borderRadius: "999px",
                      border: "1px solid #d1d5db",
                      background: "#f3f4f6",
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      fontSize: "14px",
                    }}
                    aria-label="å…³é—­"
                  >
                    âœ•
                  </button>
                </div>
                <div style={{ fontSize: "12px", color: "#6b7280" }}>
                  å½“å‰è·¯å¾„ï¼š{workspacePath} {workspaceAbs ? `ï¼ˆ${workspaceAbs}ï¼‰` : ""}
                </div>
                <div style={{ display: "flex", gap: "8px", alignItems: "center" }}>
                  <button
                    onClick={goUpWorkspace}
                    disabled={workspacePath === "."}
                    style={{
                      padding: "4px 8px",
                      borderRadius: "6px",
                      border: "1px solid #d1d5db",
                      background: workspacePath === "." ? "#f3f4f6" : "#fff",
                      cursor: workspacePath === "." ? "not-allowed" : "pointer",
                    }}
                  >
                    ä¸Šçº§
                  </button>
                  <label
                    style={{
                      padding: "4px 8px",
                      borderRadius: "6px",
                      border: "1px solid #d1d5db",
                      background: "#fff",
                      cursor: "pointer",
                    }}
                  >
                    ä¸Šä¼ æ–‡ä»¶
                    <input type="file" style={{ display: "none" }} onChange={handleUpload} />
                  </label>
                  {workspaceLoading && <span style={{ fontSize: "12px", color: "#6b7280" }}>åŠ è½½ä¸­...</span>}
                  {workspaceError && <span style={{ fontSize: "12px", color: "#ef4444" }}>{workspaceError}</span>}
                </div>
                <div
                  style={{
                    border: "1px solid #e5e7eb",
                    borderRadius: "8px",
                    padding: "8px",
                    overflow: "auto",
                    flex: 1,
                    minHeight: "240px",
                  }}
                >
                  {workspaceItems.length === 0 && !workspaceLoading ? (
                    <div style={{ color: "#6b7280", fontSize: "12px" }}>æ­¤ç›®å½•ä¸ºç©ºã€‚</div>
                  ) : (
                    workspaceItems.map((item, idx) => (
                      <div
                        key={idx}
                        style={{
                          display: "flex",
                          alignItems: "center",
                          gap: "8px",
                          padding: "6px",
                          borderBottom: "1px solid #f3f4f6",
                          cursor: item.is_dir ? "pointer" : "default",
                        }}
                        onClick={() => enterWorkspace(item.name, item.is_dir)}
                      >
                        <span>{item.is_dir ? "ğŸ“" : "ğŸ“„"}</span>
                        <span style={{ flex: 1, wordBreak: "break-all" }}>{item.name}</span>
                        <span style={{ fontSize: "12px", color: "#6b7280" }}>
                          {item.is_dir ? "ç›®å½•" : `${item.size} bytes`}
                        </span>
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>
          )}
          </>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>

